# aot

Java библиотека для быстрого (!) получения морфологической информации по заданному слову русского
языка. Реинкарнация [aot-lematizier](https://github.com/bazhenov/aot-lematizer), избавленная от
closed-source зависимостей, упрощенная для сборки, как следствие легко подключаемая в другие
проекты.

1. Определяет исходную форму слова согласно правилам языка, т. н. лемму, первое лицо, единственное
   число.
2. Определяет всевозможные характеристики слова, такие как род, падеж, число и т. п.
3. Определяет всевозможные преобразования леммы (flexion).

## Как подключить?

[![](https://jitpack.io/v/demidko/aot.svg)](https://jitpack.io/#demidko/aot)

## Как использовать?

Продемонстрируем работу словаря на примере смысловой коллизии:

```java
// на создание словаря уходит несколько секунд,
// поэтому, лучше иметь один экземпляр на все время работы
var d = new com.github.demidko.aot.HashDictionary(); 
// получаем все наборы смыслов по интересующему нас слову
for (var word : d.lookup("замок")) {
  // проходим по всем возможным словоформам каждого смысла
  for (var flex : word.getFlexions()) {
    // и выводим их характеристики
    System.out.print(flex.toString() + flex.getTags());
    System.out.print(' ');
  }
  System.out.println("\n");
}
```

Получим что-то вроде

```shell
1. <замок, [С, мр, ед, им], [С, мр, ед, вн]> ..., ...
2. <замокнуть, [Г, дст, прш, мр, ед]> ..., ...
```

Первая лемма, это слово зАмок (строение). Это либо замок (кто?) в именительном падеже, либо замок (
кого?) в винительном падеже. Она же одновременно характеризует слово замОк (устройство для запирания
дверей). Для нее, слово замок так же может быть либо именительным, либо винительным падежом. И
наконец, третий смысл, это лемма замокнуть (он что сделал? Он замок под дождем). Для нее слово замок
характеризуется лишь одним набором грамматической информации.

## Откуда взяты данные?

Используется словарь бинарной морфологии из
проекта [aot-binary](https://github.com/demidko/aot-binary).







